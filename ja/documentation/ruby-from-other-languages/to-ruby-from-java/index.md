---
layout: page
title: "JavaからRubyへ"
lang: ja
---

Javaは成熟しており、よくテストされています。
アンチJavaな人々が訴えるのに反して、Javaは高速です。ですが、とても冗長です。
JavaからRubyへ移行すると、コードの量を大幅に削減できます。
プロトタイピングを少ない時間で済ませられるようになるでしょう。

### Javaとの類似

Javaと同様に、Rubyは...

* メモリはGCによって管理されます。
* オブジェクトは強い型付けがされます。
* メソッドにはpublic、private、protectedを指定できます。
* 埋め込み型のドキュメントツールがあります(Ruby用のツールはRDocと呼ばれます)。
  rdocで生成されたドキュメントはjavadocで生成したドキュメントにとてもよく似ています。

### Javaとの違い

Javaと違って、Rubyは...

* コードをコンパイルする必要はありません。単に実行するだけです。
* 異なったサードパーティ製のGUIツールキットがいくつか存在します。
  Rubyのユーザーは、たとえば[WxRuby][1]、[FXRuby][2]、[Ruby-GNOME2][3]、[Qt][4]、
  あるいはRubyに同梱されているRuby Tkなどを利用します。
* クラスなどの定義の最後には`end`キーワードを使います。コードのまとまりを波括弧で括ることはしません。
* `import`の代わりに`require`を使います。
* すべてのメンバ変数はプライベート変数です。オブジェクトの外側からはメソッドを介してそれらにアクセスします。
* メソッド呼び出しの括弧は基本的にオプションで、しばしば省略されます。
* 2や3.14159といった数値も含めて、すべてのものはオブジェクトです。
* 静的型チェックはありません。
* 変数名はただのラベルです。変数名は関連付けられた型を持ちません。
* 型宣言はありません。必要に応じて新しい変数名を割りあてれば、それらを利用できます
  (`int[] a = {1,2,3};`ではなく`a = [1,2,3]`というように)。
* キャストはありません。メソッドを呼び出すだけです。
  例外を確認するつもりなら、コードを実行する前にユニットテストで示しましょう。
* `Foo foo = new Foo("hi")`は`foo = Foo.new("hi")`と書きます。
* コンストラクタは常に“initialize”という名前になります。クラス名ではありません。
* インターフェイスの代わりにMix-inを使います。
* XMLよりもYAMLが好まれます。
* `null`は`nil`です。
* `==`と`equals()`の扱いが異なります。等価かどうかを評価したい時(Javaで`equals()`を使うケース)は`==`を使います。
  二つのオブジェクトが同一かどうかを確認したい時(Javaで`==`を使うケース)は`equal?()`を使います。



[1]: https://github.com/eumario/wxruby
[2]: https://github.com/larskanis/fxruby
[3]: https://ruby-gnome2.osdn.jp/
[4]: https://github.com/ryanmelt/qtbindings/
