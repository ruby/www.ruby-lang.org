---
layout: page
title: "Ruby в 20 минути"
lang: bg

header: |
  <div class="multi-page">
    <a href="../" title="Част 1">1</a>
    <span class="separator"> | </span>
    <a href="../2/" title="Част 2">2</a>
    <span class="separator"> | </span>
    <a href="../3/" title="Част 3">3</a>
    <span class="separator"> | </span>
    <strong>4</strong>
  </div>
  <h1>Ruby в 20 минути</h1>

---

Ако погледнем по-отблизо нашата нова програма, ще забележим, че
присъства ред, който започва с #. В Ruby всичко, което започва с # е
коментар и не се интерпретира. Конкретно в нашия пример се ползва
специален случай, който показва как да бъде стартиран файла под
UNIX-подобни операционни системи.

Въведохме известна промяна в метода `say_hi`\:

{% highlight ruby %}
# Say hi to everybody
def say_hi
  if @names.nil?
    puts "..."
  elsif @names.respond_to?("each")
    # @names is a list of some kind, iterate!
    @names.each do |name|
      puts "Hello #{name}!"
    end
  else
    puts "Hello #{@names}!"
  end
end
{% endhighlight %}

В горния пример правим проверка на параметъра `@names` за да вземем
решение. Ако е nil, отпечатваме три точки.

## Цикли, познати като итерации

Ако обектът `@names` отговаря на `each`, би следвало да можем да минем
през всеки един от неговите елементи и да отпечатаме неговата стойност.
Ако това не стане, просто превръщаме обекта в низ и отпечатваме
стандартния поздрав.

Нека разгледаме итератора от близо:

{% highlight ruby %}
@names.each do |name|
  puts "Hello #{name}!"
end
{% endhighlight %}

Методът `each` приема блок с код, който се изпълнява за всеки елемент от
списъка, бит по бит, между ключовите думи `do` и `end.  Блокът е като
анонимната функция @lambda`. Променливата между вертикалните черти е
параметъра за този блок.

В повечето езици за програмиране се ползва цикъл като `for` за обхождане
на списъка, като това става на C по следния начин:

{% highlight c %}
for (i=0; i<number_of_elements; i++)
{
  do_something_with(element[i]);
}
{% endhighlight %}

Този вариант работи, но не е най-елегантното решение. Имаме нужда от
променлива i, големината на списъка и описание на начина на обхождане. В
Ruby това става много елегантно, като всички детайли са скрити в метода
`each`. Вътрешната реализация на този метод просто извиква `yield
"Albert"`, след това `yield "Brenda"` и накрая `yield "Charles"`

## Блокът, блясъкът на Ruby

Истинската мощ на блоковете може да видим в обработката на сложни
списъци.

{% highlight ruby %}
# Say bye to everybody
def say_bye
  if @names.nil?
    puts "..."
  elsif @names.respond_to?("join")
    # Join the list elements with commas
    puts "Goodbye #{@names.join(", ")}.  Come back soon!"
  else
    puts "Goodbye #{@names}.  Come back soon!"
  end
end
{% endhighlight %}

Методът `say_bye` не използва `each`, а вместо това прави проверка дали
`@names` отговаря на метода `join` и при положителен резултат го ползва.
При отрицателен резултат просто отпечатва променливата като низ. Този
метод не се интересува от типа на променливата, а се уповава на
методите, на които отговаря, като това е познато като “Duck Typing” –
“ако ходи като патица и кряка като патица, би трябвало да е патица”. По
този начин не сме ограничени от типа на променливите. Ако някой друг
напише подобен клас, единственото нещо, което трябва да присъства е
имплементацията на метода `join` за да може всичко да работи правилно.

## Стартиране на скрипта

Ползваме един последен трик за стартиране на скрипта:

{% highlight ruby %}
if __FILE__ == $0
{% endhighlight %}

`__FILE__` е специална променлива, която съдържа името на настоящия
файл, а `$0` представлява името на файла, нужен за стартирането на
програмата. Тази проверка има следното значение: “Ако това е главния
изпълним файл ...”. Това ни позволява да ползваме скрипта като
библиотека.

## Вместо край на ръководството

Тук приключва краткото въведение в Ruby. Надяваме се това да Ви е
запалило да научите и използвате този прекрасен език. Ако това е така,
можете да прегледате раздела [Документация](/bg/documentation/) , където
ще намерите връзки към напълно безплатни самоучители и ръководства.
