---
layout: news_post
title: "Уязвимость объектов через DL и Fiddle в Ruby (CVE-2013-2065)"
author: "usa"
translator: "gazay"
date: 2013-05-14 13:00:00 +0000
tags: security
lang: ru
---

Уязвимость в DL и Fiddle в Ruby, где испорченные строки могут быть
использованы системными вызовами, не смотря на установленный в Ruby уровень $SAFE.
Этой уязвимости назначен CVE идентификатор CVE-2013-2065.

## Влияние

Нативные функции, действующие в Ruby с DL или Fiddle, не проверяют
испорченности выставленных значений поступающих в объекты. Как
результат, испорченные объекты могут быть приняты как обычные, когда как
должна быть брошена ошибка SecurityError.

Пример DL кода будет выглядеть как-то так:

{% highlight ruby %}
def my_function(user_input)
  handle    = DL.dlopen(nil)
  sys_cfunc = DL::CFunc.new(handle['system'], DL::TYPE_INT, 'system')
  sys       = DL::Function.new(sys_cfunc, [DL::TYPE_VOIDP])
  sys.call user_input
end

$SAFE = 1
my_function "uname -rs".taint
{% endhighlight %}

Пример Fiddle кода будет выглядеть как-то так:

{% highlight ruby %}
def my_function(user_input)
  handle    = DL.dlopen(nil)
  sys = Fiddle::Function.new(handle['system'],
                             [Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
  sys.call user_input
end

$SAFE = 1
my_function "uname -rs".taint
{% endhighlight %}

Все пользователи, использующие затронутые релизы, должны либо обновить,
либо использовать один из обходных путей немедленно.

Заметьте, что это *не* отменит использования числовых отступов в памяти как
значения указателей. Числа не могут быть загрязнены, так что код
создающий числовой отступ в памяти, не может быть проверен. Например:

{% highlight ruby %}
def my_function(input)
  handle    = DL.dlopen(nil)
  sys = Fiddle::Function.new(handle['system'],
                             [Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
  sys.call input
end

$SAFE = 1
user_input = "uname -rs".taint
my_function DL::CPtr[user_input].to_i
{% endhighlight %}

В этом случае позиция в памяти передана и загрязненность объекта не
может быть определена DL / Fiddle. В данном случае, пожалуйста
проверяйте загрязненность пользовательского ввода перед тем как
передавать позицию в памяти:

{% highlight ruby %}
user_input = "uname -rs".taint
raise if $SAFE >= 1 && user_input.tainted?
my_function DL::CPtr[user_input].to_i
{% endhighlight %}

## Обходные пути

Если вы не можете обновить Ruby, данный манкипатч может быть использован
как обходной путь:

{% highlight ruby %}
class Fiddle::Function
  alias :old_call :call
  def call(*args)
    if $SAFE >= 1 && args.any? { |x| x.tainted? }
      raise SecurityError, "tainted parameter not allowed"
    end
    old_call(*args)
  end
end
{% endhighlight %}

## Затронутые версии

* Все версии ruby 1.9 до ruby 1.9.3 patchlevel 426
* Все версии ruby 2.0 до ruby 2.0.0 patchlevel 195
* транк ветка до ревизии 40728

ruby 1.8 версии не затронуты

## Благодарность

Спасибо Vit Ondruch за сообщение о данной проблеме.

## История

* Оригинал опубликован 2013-05-14 13:00:00 (UTC)
