---
layout: news_post
title: "Обхід таїнтування об'єкта в DL та Fiddle в Ruby (CVE-2013-2065)"
author: "usa"
translator: "Andrii Furmanets"
date: 2013-05-14 13:00:00 +0000
tags: security
lang: uk
---

Є вразливість у DL та Fiddle в Ruby, де таїнтовані рядки можуть бути
використані системними викликами незалежно від рівня $SAFE, встановленого в Ruby. Цій
вразливості присвоєно ідентифікатор CVE CVE-2013-2065.

## Вплив

Нативні функції, виставлені до Ruby з DL або Fiddle, не перевіряють значення таїнтування
, встановлені на об'єктах, переданих. Це може призвести до прийняття таїнтованих об'єктів як
вхідних даних, коли повинен бути викликаний виняток SecurityError.

Зачеплений код DL виглядатиме приблизно так:

{% highlight ruby %}
def my_function(user_input)
  handle    = DL.dlopen(nil)
  sys_cfunc = DL::CFunc.new(handle['system'], DL::TYPE_INT, 'system')
  sys       = DL::Function.new(sys_cfunc, [DL::TYPE_VOIDP])
  sys.call user_input
end

$SAFE = 1
my_function "uname -rs".taint
{% endhighlight %}

Зачеплений код Fiddle виглядатиме приблизно так:

{% highlight ruby %}
def my_function(user_input)
  handle    = DL.dlopen(nil)
  sys = Fiddle::Function.new(handle['system'],
                             [Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
  sys.call user_input
end

$SAFE = 1
my_function "uname -rs".taint
{% endhighlight %}

Всі користувачі, які запускають зачеплений випуск, повинні або оновитися, або використовувати один з
обхідних шляхів негайно.

Зверніть увагу, що це *не* запобігає використанню числових зміщень пам'яті як
значень покажчика. Числа не можуть бути таїнтованими, тому код, який передає числове зміщення пам'яті
, не може бути перевірений. Наприклад:

{% highlight ruby %}
def my_function(input)
  handle    = DL.dlopen(nil)
  sys = Fiddle::Function.new(handle['system'],
                             [Fiddle::TYPE_VOIDP], Fiddle::TYPE_INT)
  sys.call input
end

$SAFE = 1
user_input = "uname -rs".taint
my_function DL::CPtr[user_input].to_i
{% endhighlight %}

У цьому випадку передається місце розташування пам'яті, і таїнтування об'єкта
не може бути визначено DL / Fiddle. У цьому випадку, будь ласка, перевірте таїнтування
вхідних даних користувача перед передачею місця розташування пам'яті:

{% highlight ruby %}
user_input = "uname -rs".taint
raise if $SAFE >= 1 && user_input.tainted?
my_function DL::CPtr[user_input].to_i
{% endhighlight %}

## Обхідні шляхи

Якщо ви не можете оновити Ruby, цей monkey patch може використовуватися як обхідний шлях:

{% highlight ruby %}
class Fiddle::Function
  alias :old_call :call
  def call(*args)
    if $SAFE >= 1 && args.any? { |x| x.tainted? }
      raise SecurityError, "tainted parameter not allowed"
    end
    old_call(*args)
  end
end
{% endhighlight %}

## Зачеплені версії

* Всі версії ruby 1.9 до ruby 1.9.3 рівня патчу 426
* Всі версії ruby 2.0 до ruby 2.0.0 рівня патчу 195
* до ревізії trunk 40728

версії ruby 1.8 не зачеплені.

## Подяка

Дякуємо Vit Ondruch за повідомлення про цю проблему.

## Історія

* Спочатку опубліковано 2013-05-14 13:00:00 (UTC)

