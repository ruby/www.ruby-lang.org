---
layout: news_post
title: "Розділення позиційних і ключових аргументів у Ruby 3.0"
author: "mame"
translator: "Andrii Furmanets"
date: 2019-12-12 12:00:00 +0000
lang: uk
---

Ця стаття пояснює заплановану несумісність ключових аргументів у Ruby 3.0

## tl;dr

У Ruby 3.0 позиційні аргументи та ключові аргументи будуть розділені. Ruby 2.7 попереджатиме про поведінку, яка зміниться в Ruby 3.0. Якщо ви бачите такі попередження, вам потрібно оновити свій код:

* `Using the last argument as keyword parameters is deprecated`, або
* `Passing the keyword argument as the last hash parameter is deprecated`, або
* `Splitting the last argument into positional and keyword parameters is deprecated`

У більшості випадків можна уникнути несумісності, додавши оператор _double splat_. Він явно вказує на передачу ключових аргументів замість об'єкта `Hash`. Так само можна додати фігурні дужки `{}`, щоб явно передати об'єкт `Hash` замість ключових аргументів. Докладніше читайте в розділі «Типові випадки» нижче.

У Ruby 3 метод, який делегує всі аргументи, повинен явно делегувати ключові аргументи на додаток до позиційних. Якщо ви хочете зберегти поведінку делегування з Ruby 2.7 і раніших версій, використовуйте `ruby2_keywords`. Докладніше див. у розділі «Обробка делегування аргументів».

## Типові випадки
{: #typical-cases }

Ось найтиповіший випадок. Використовуйте оператор double splat (`**`) для передачі ключових слів замість Hash.

{% highlight ruby %}
# Цей метод приймає лише ключовий аргумент
def foo(k: 1)
  p k
end

h = { k: 42 }

# Цей виклик методу передає позиційний аргумент Hash
# У Ruby 2.7: Hash автоматично перетворюється на ключовий аргумент
# У Ruby 3.0: Цей виклик викликає ArgumentError
foo(h)
  # => demo.rb:11: warning: Using the last argument as keyword parameters is deprecated; maybe ** should be added to the call
  #    demo.rb:2: warning: The called method `foo' is defined here
  #    42

# Щоб зберегти поведінку в Ruby 3.0, використовуйте double splat
foo(**h) #=> 42
{% endhighlight %}

Ось інший випадок. Використовуйте фігурні дужки (`{}`) для явної передачі Hash замість ключових слів.

{% highlight ruby %}
# Цей метод приймає один позиційний аргумент і решту ключових аргументів
def bar(h, **kwargs)
  p h
end

# Цей виклик передає тільки ключовий аргумент і жодних позиційних
# У Ruby 2.7: Ключове слово перетворюється на позиційний аргумент Hash
# У Ruby 3.0: Цей виклик викликає ArgumentError
bar(k: 42)
  # => demo2.rb:9: warning: Passing the keyword argument as the last hash parameter is deprecated
  #    demo2.rb:2: warning: The called method `bar' is defined here
  #    {:k=>42}

# Щоб зберегти поведінку в Ruby 3.0, використовуйте фігурні дужки
bar({ k: 42 }) # => {:k=>42}
{% endhighlight %}

## Що застаріло?
{: #what-is-deprecated }

У Ruby 2 ключові аргументи можуть оброблятися як останній позиційний аргумент Hash, і навпаки — останній позиційний Hash може оброблятися як ключові аргументи.

Оскільки автоматичне перетворення іноді занадто складне й проблемне (як описано в останньому розділі), воно застаріло в Ruby 2.7 і буде видалено в Ruby 3. Іншими словами, в Ruby 3 ключові аргументи будуть повністю відокремлені від позиційних. Отже, коли ви хочете передати ключові аргументи, завжди використовуйте `foo(k: expr)` або `foo(**expr)`. Якщо хочете приймати ключові аргументи, в принципі завжди використовуйте `def foo(k: default)` або `def foo(k:)` або `def foo(**kwargs)`.

Зверніть увагу, що Ruby 3.0 поводиться так само при виклику методу, який не приймає ключові аргументи, з ключовими аргументами. Наприклад, наступний випадок не буде застарілим і працюватиме в Ruby 3.0. Ключові аргументи все ще обробляються як позиційний аргумент Hash.

{% highlight ruby %}
def foo(kwargs = {})
  kwargs
end

foo(k: 1) #=> {:k=>1}
{% endhighlight %}

Це тому, що цей стиль використовується дуже часто, і немає неоднозначності в тому, як слід обробляти аргумент.

Однак цей стиль не рекомендується в новому коді, якщо ви не часто передаєте Hash як позиційний аргумент і також використовуєте ключові аргументи. В іншому випадку використовуйте double splat:

{% highlight ruby %}
def foo(**kwargs)
  kwargs
end

foo(k: 1) #=> {:k=>1}
{% endhighlight %}

## Чи зламається мій код на Ruby 2.7?
{: #break-on-ruby-2-7 }

Коротка відповідь: «можливо, ні».

Зміни в Ruby 2.7 розроблено як шлях міграції до 3.0. Хоча в принципі Ruby 2.7 лише попереджає про поведінку, яка зміниться в Ruby 3, він включає деякі несумісні зміни, які ми вважаємо незначними. Докладніше див. розділ «Інші незначні зміни».

За винятком попереджень і незначних змін, Ruby 2.7 намагається зберегти сумісність з Ruby 2.6. Отже, ваш код, ймовірно, працюватиме на Ruby 2.7, хоча може видавати попередження. І запустивши його на Ruby 2.7, ви можете перевірити, чи готовий ваш код до Ruby 3.0.

Якщо хочете вимкнути попередження про застаріння, використовуйте аргумент командного рядка `-W:no-deprecated` або додайте `Warning[:deprecated] = false` у свій код.

## Обробка делегування аргументів
{: #delegation }

### Ruby 2.6 або раніше
{: #delegation-ruby-2-6-or-prior }

У Ruby 2 можна написати метод делегування, приймаючи аргумент `*rest` і аргумент `&block`, і передаючи обидва до цільового методу. У цій поведінці ключові аргументи також неявно обробляються автоматичним перетворенням між позиційними та ключовими аргументами.

{% highlight ruby %}
def foo(*args, &block)
  target(*args, &block)
end
{% endhighlight %}

### Ruby 3
{: #delegation-ruby-3 }

Потрібно явно делегувати ключові аргументи.

{% highlight ruby %}
def foo(*args, **kwargs, &block)
  target(*args, **kwargs, &block)
end
{% endhighlight %}

Альтернативно, якщо вам не потрібна сумісність з Ruby 2.6 або раніше і ви не змінюєте жодних аргументів, можете використовувати новий синтаксис делегування (`...`), введений у Ruby 2.7.

{% highlight ruby %}
def foo(...)
  target(...)
end
{% endhighlight %}

### Ruby 2.7
{: #delegation-ruby-2-7 }

Коротко: використовуйте `Module#ruby2_keywords` і делегуйте `*args, &block`.

{% highlight ruby %}
ruby2_keywords def foo(*args, &block)
  target(*args, &block)
end
{% endhighlight %}

`ruby2_keywords` приймає ключові аргументи як останній аргумент Hash і передає їх як ключові аргументи при виклику іншого методу.

### Сумісне делегування для Ruby 2.6, 2.7 і Ruby 3
{: #a-compatible-delegation }

Коротко: знову використовуйте `Module#ruby2_keywords`.

{% highlight ruby %}
ruby2_keywords def foo(*args, &block)
  target(*args, &block)
end
{% endhighlight %}

На жаль, нам потрібно використовувати старий стиль делегування (тобто без `**kwargs`), оскільки Ruby 2.6 або раніше не обробляє новий стиль делегування правильно. Це одна з причин розділення ключових аргументів. І `ruby2_keywords` дозволяє запускати старий стиль навіть у Ruby 2.7 і 3.0. Оскільки `ruby2_keywords` не визначено в 2.6 або раніше, використовуйте [гем ruby2_keywords](https://rubygems.org/gems/ruby2_keywords) або визначте його самостійно:

{% highlight ruby %}
def ruby2_keywords(*)
end if RUBY_VERSION < "2.7"
{% endhighlight %}

---

Якщо вашому коду не потрібно працювати на Ruby 2.6 або старішому, можете спробувати новий стиль у Ruby 2.7. У майже всіх випадках він працює. Однак зверніть увагу на кутові випадки:

{% highlight ruby %}
def target(*args)
  p args
end

def foo(*args, **kwargs, &block)
  target(*args, **kwargs, &block)
end

foo({})       #=> Ruby 2.7: []   ({} відкидається)
foo({}, **{}) #=> Ruby 2.7: [{}] (Можете передати {} явно вказавши «без» ключових слів)
{% endhighlight %}

Порожній аргумент Hash автоматично перетворюється і поглинається в `**kwargs`, і виклик делегування видаляє порожній keyword hash, тому жодного аргументу не передається в `target`.

Якщо ви справді турбуєтесь про переносимість, використовуйте `ruby2_keywords`. `ruby2_keywords` може бути видалено в майбутньому після того, як Ruby 2.6 досягне кінця життєвого циклу. На той момент ми рекомендуємо явно делегувати ключові аргументи.

## Інші незначні зміни
{: #other-minor-changes }

У Ruby 2.7 є три незначні зміни щодо ключових аргументів.

### 1. Не-Symbol ключі дозволені в ключових аргументах
{: #other-minor-changes-non-symbol-keys }

У Ruby 2.6 або раніше в ключових аргументах дозволялися лише Symbol-ключі. У Ruby 2.7 ключові аргументи можуть використовувати не-Symbol ключі.

{% highlight ruby %}
def foo(**kwargs)
  kwargs
end
foo("key" => 42)
  #=> Ruby 2.6 або раніше: ArgumentError: wrong number of arguments
  #=> Ruby 2.7 або пізніше: {"key"=>42}
{% endhighlight %}

### 2. Double splat з порожнім hash (`**{}`) не передає аргументів
{: #other-minor-changes-empty-hash }

У Ruby 2.6 або раніше передача `**empty_hash` передавала порожній Hash як позиційний аргумент. У Ruby 2.7 або пізніше він не передає жодних аргументів.

{% highlight ruby %}
def foo(*args)
  args
end

empty_hash = {}
foo(**empty_hash)
  #=> Ruby 2.6 або раніше: [{}]
  #=> Ruby 2.7 або пізніше: []
{% endhighlight %}

### 3. Введено синтаксис без ключових аргументів (`**nil`)
{: #other-minor-changes-double-splat-nil }

Можна використовувати `**nil` у визначенні методу, щоб явно позначити, що метод не приймає ключових аргументів. Виклик таких методів з ключовими аргументами призведе до `ArgumentError`.

{% highlight ruby %}
def foo(*args, **nil)
end

foo(k: 1)
  #=> Ruby 2.7 або пізніше: no keywords accepted (ArgumentError)
{% endhighlight %}

## Чому ми застаріли автоматичне перетворення
{: #why-deprecated }

Автоматичне перетворення спочатку здавалося гарною ідеєю і добре працювало в багатьох випадках. Однак у нього було занадто багато кутових випадків, і ми отримали багато звітів про помилки щодо цієї поведінки.

Автоматичне перетворення не працює добре, коли метод приймає опціональні позиційні аргументи та ключові аргументи. Деякі люди очікують, що останній об'єкт Hash буде оброблено як позиційний аргумент, а інші очікують, що він буде перетворено на ключові аргументи.

Ось один з найбільш заплутаних випадків:

{% highlight ruby %}
def foo(x, **kwargs)
  p [x, kwargs]
end

def bar(x=1, **kwargs)
  p [x, kwargs]
end

foo({}) #=> [{}, {}]
bar({}) #=> [1, {}]

bar({}, **{}) #=> очікувано: [{}, {}], фактично: [1, {}]
{% endhighlight %}

У Ruby 2, `foo({})` передає порожній hash як звичайний аргумент (тобто `{}` присвоюється `x`), тоді як `bar({})` передає ключовий аргумент (тобто `{}` присвоюється `kwargs`). Отже, `any_method({})` дуже неоднозначний.

## Подяки

Цю статтю люб'язно переглянули (або навіть співавторчо написали) Jeremy Evans і Benoit Daloze.

## Історія

* Оновлено 2019-12-25: У 2.7.0-rc2 повідомлення попередження було трохи змінено, і додано API для придушення попереджень.
