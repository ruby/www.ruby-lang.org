---
layout: news_post
title: "\"Ruby Hacking Guide\" вийшов, хоча ..."
author: "NaHi"
translator: "Andrii Furmanets"
lang: uk
---

[![RHG](http://direct.ips.co.jp/directsys/Images/Goods/1/1721B.gif){:
.icon width="70" height="88"}][cover] Книга під назвою "Ruby source code Kanzen
Kaisetsu – Ruby Hacking Guide" від Aoki-san вийшла, хоча вона написана
японською мовою…

Це обов'язковий елемент для Ruby хакера, який може читати японською. :(

* Видавець: Impress
* Автор: AOKI, Minero під редакцією MATSUMOTO, Yukihiro
* ISBN: 4-8443-1721-0

[cover]: http://direct.ips.co.jp/book/Template/Goods/go_BookstempGR.cfm?GM_ID=1721&amp;SPM_ID=1&amp;CM_ID=004000G20&amp;PM_No=&amp;PM_Class=&amp;HN_NO=00420

Я спробував перекласти зміст.
Майте на увазі, що це неофіційний переклад.

    Передмова
    i      Цільовий читач
    ii     Структура цієї книги
    iii    Середовище
    ix     Веб-сайт
    x      Подяки
    0      Передмова
    0.1    Характеристики Ruby
    0.2    Як хакнути вихідний код
    0.2.1  Принцип
    0.2.2  Аналітична техніка
    0.2.3  Динамічний аналіз
    0.2.4  Статичний аналіз
    0.2.5  Історія знає все
    0.2.6  Інструмент для статичного аналізу
    0.3    Збірка
    0.3.1  Версія
    0.3.2  Отримання вихідного коду
    0.3.3  Компіляція
    0.4    Деталі збірки
    0.4.1  configure
    0.4.2  autoconf
    0.4.3  make
    0.5    CVS
    0.5.1  Вивчіть CVS за 50 рядків
    0.6    Структура вихідного коду ruby
    0.6.1  Фізична структура
    0.6.2  Розділення вихідного коду
    0.6.3  Логічна структура
    Розділ I: Об'єкт
    1.     Мінімум мови Ruby
    1.1    Об'єкт
    1.1.1  String
    1.1.2  Різні літерали
    1.1.3  Виклик методу
    1.2    Програма
    1.2.1  Top-level
    1.2.2  Локальна змінна
    1.2.3  Константна змінна
    1.2.4  Структура керування
    1.3    Клас та метод
    1.3.1  Клас
    1.3.2  Визначення класу
    1.3.3  Визначення методу
    1.3.4  self
    1.3.5  Змінна екземпляра
    1.3.6  Initialize
    1.3.7  Наслідування
    1.3.8  Наслідування змінної ... ?
    1.3.9  Module
    1.4    Програма II
    1.4.1  Вкладена константа
    1.4.2  Все оцінюється
    1.4.3  Область видимості локальної змінної
    1.4.4  self як контекст
    1.4.5  Завантаження
    1.5    Про клас, більше
    1.5.1  Про константу продовжується
    1.5.2  Мета-клас
    1.5.3  Мета-об'єкт
    1.5.4  Singleton метод
    1.5.5  Змінна класу
    1.6    Глобальна змінна
    2.     Об'єкт
    2.1    Структура об'єкта Ruby
    2.1.1  Керівні принципи
    2.1.2  VALUE та структура об'єкта
    2.1.3  Вбудовані об'єкти в VALUE
    2.2    Метод
    2.2.1  struct RClass
    2.2.2  Пошук методу
    2.3    Змінна екземпляра
    2.3.1  rb_ivar_set()
    2.3.2  generic_ivar_set()
    2.3.3  Проміжок у структурі
    2.3.4  rb_ivar_get()
    2.4    Структура об'єкта
    2.4.1  struct RString
    2.4.2  struct RArray
    2.4.3  struct RRegexp
    2.4.4  struct RHash
    2.4.5  struct RFile
    2.4.6  struct RData
    3.     Ім'я та таблиця імен
    3.1    st_table
    3.1.1  Контур
    3.1.2  Структура даних
    3.1.3  Приклад st_hash_type
    3.1.4  st_lookup()
    3.1.5  st_add_direct()
    3.1.6  st_insert()
    3.2    ID та символ
    3.2.1  Від char* до ID
    3.2.2  Від ID до char*
    3.2.3  Перетворення між VALUE та ID
    4.     Клас та модуль
    4.1    Визначення класу та методу
    4.1.1  Визначення класу
    4.1.2  Визначення вкладеного класу
    4.1.3  Визначення модуля
    4.1.4  Визначення методу
    4.1.5  Визначення singleton методу
    4.1.6  Точка входу
    4.2    Singleton клас
    4.2.1  rb_define_singleton_method()
    4.2.2  rb_singleton_class()
    4.2.3  Звичайний клас та singleton клас
    4.2.4  Стиснення rb_singleton_class()
    4.2.5  Стиснення rb_make_metaclass()
    4.2.6  Що таке singleton клас
    4.2.7  Singleton клас та екземпляр
    4.2.8  Підсумок
    4.3    Мета-клас
    4.3.1  Наслідування singleton методу
    4.3.2  Singleton клас класу
    4.3.3  Клас класу класу
    4.3.4  Singleton клас та мета-клас
    4.3.5  Bootstrap
    4.4    Ім'я класу
    4.4.1  Ім'я до класу
    4.4.2  Клас до імені
    4.4.3  Рівень вкладеності 2 або більше
    4.4.4  Анонімний клас
    4.5    Include
    4.5.1  rb_include_module (1)
    4.5.2  include_class_new()
    4.5.3  Симуляція
    4.5.4  rb_include_module (2)
    5.     Збірка сміття
    5.1    Образ пам'яті під час виконання
    5.1.1  Сегмент
    5.1.2  alloca()
    5.2    Контур
    5.2.1  Що таке GC
    5.2.2  Що робиться в GC
    5.2.3  Mark & sweep
    5.2.4  Stop & copy
    5.2.5  Підрахунок посилань
    5.3    Управління об'єктами
    5.3.1  struct RVALUE
    5.3.2  Куча об'єктів
    5.3.3  freelist
    5.3.4  add_heap()
    5.3.5  rb_newobj()
    5.4    Mark
    5.4.1  rb_gc_mark()
    5.4.2  rb_gc_mark_children()
    5.4.3  rb_gc()
    5.4.4  Стек Ruby
    5.4.5  Регістр
    5.4.6  Машинний стек
    5.4.7  Інші кореневі об'єкти
    5.5    Sweep
    5.5.1  Спеціальне оброблення для NODE
    5.5.2  Фіналізатор
    5.5.3  rb_gc_force_recycle()
    5.6    Роздуми
    5.6.1  Звільнення простору пам'яті
    5.6.2  Покоління GC
    5.6.3  Компактність
    5.6.4  volatile, заходи проти GC
    5.7    Час початку
    5.7.1  Всередині gc.c
    5.7.2  В інтерпретаторі
    5.8    Виділення об'єкта
    5.8.1  Фреймворк виділення
    5.8.2  Виділення користувацького об'єкта
    5.8.3  Проблема фреймворку виділення
    6.     Змінна та константа
    6.1    Контур цього розділу
    6.1.1  Змінна Ruby
    6.1.2  Ruby API для змінної
    6.1.3  Точка цього розділу
    6.2    Змінна класу
    6.2.1  Посилання
    6.3    Константа
    6.3.1  Присвоєння
    6.3.2  Посилання
    6.4    Глобальна змінна
    6.4.1  Загальні зауваження
    6.4.2  Структура даних
    6.4.3  Посилання
    7.     Безпека
    7.1    Принцип
    7.2    Реалізація
    Розділ II: Синтаксичний аналіз
    8.     Мова Ruby детально
    8.1    Літерал
    8.1.1  String
    8.1.2  Символ
    8.1.3  Регулярний вираз
    8.1.4  Масив
    8.1.5  Hash
    8.1.6  Діапазон
    8.1.7  Symbol
    8.1.8  Числове значення
    8.2    Метод
    8.2.1  Визначення та виклик
    8.2.2  Значення методу
    8.2.3  Опустимий аргумент
    8.2.4  Опущення дужок для аргументу
    8.2.5  Аргумент та масив
    8.2.6  Різні форми виклику
    8.2.7  super
    8.3    Ітератор
    8.3.1  Порівняння з функцією вищого порядку
    8.3.2  Локальна змінна блоку
    8.3.3  Синтаксис ітератора
    8.3.4  yield
    8.3.5  Proc
    8.4    Вираз
    8.4.1  if
    8.4.2  unless
    8.4.3  and && or ||
    8.4.4  Умовний арифметичний оператор
    8.4.5  while until
    8.4.6  case
    8.4.7  Виняток
    8.4.8  Змінна та константа
    8.4.9  Присвоєння
    8.4.10 Самоприсвоєння
    8.4.11 defined?
    8.5    Речення
    8.5.1  Термінал речення
    8.5.2  Модифікатор if/unless
    8.5.3  Модифікатор while/until
    8.5.4  Визначення класу
    8.5.5  Визначення методу
    8.5.6  Визначення singleton методу
    8.5.7  Визначення singleton класу
    8.5.8  Множинне присвоєння
    8.5.9  alias
    8.5.10 undef
    8.6    Інше
    8.6.1  Коментар
    8.6.2  Вбудований документ
    8.6.3  Мультибайтовий символ
    9.     yacc за день
    9.1    Контур
    9.1.1  Парсер та сканер
    9.1.2  Послідовність символів
    9.1.3  Генератор парсерів
    9.2    Грамматика
    9.2.1  Файл граматики
    9.2.2  Що робить yacc
    9.2.3  BNF
    9.2.4  Термінальний та нетермінальний символ
    9.2.5  Метод тестування
    9.2.6  Порожнє правило
    9.2.7  Рекурсивне визначення
    9.3    Побудова значення
    9.3.1  Shift та reduce
    9.3.2  Дія
    9.3.3  Значення символу
    9.3.4  yacc та тип
    9.3.5  Підключення парсера та сканера
    9.3.6  Вбудована дія
    9.4    Реалістична тема
    9.4.1  Колізія
    9.4.2  Lookahead
    9.4.3  Порядок пріоритету оператора
    10.    Парсер
    10.1   Керівні принципи
    10.1.1 Побудова парсера
    10.1.2 Розділення parse.y
    10.2   Загальні зауваження про правило граматики
    10.2.1 Правило кодування
    10.2.2 Важливий символ
    10.2.3 Загальна структура
    10.2.4 program
    10.2.5 stmt
    10.2.6 expr
    10.2.7 arg
    10.2.8 primary
    10.2.9 Колізія списку
    10.3   Сканер
    10.3.1 Ескіз парсера
    10.3.2 Буфер вводу
    10.3.3 Буфер токенів
    10.3.4 yylex()
    10.3.5 Тип рядка
    11.    Сканер стану
    11.1   Контур
    11.1.1 Конкретний приклад
    11.1.2 lex_state
    11.1.3 Читання сканера стану
    11.1.4 Про кожен стан
    11.2   Керування переносом рядка
    11.2.1 Проблема
    11.2.2 Реалізація
    11.3   Ім'я методу, яке є зарезервованим словом
    11.3.1 Проблема
    11.3.2 Визначення методу
    11.3.3 Виклик методу
    11.3.4 Symbol
    11.4   Модифікатор
    11.4.1 Проблема
    11.4.2 Реалізація
    11.5   Колізія do
    11.5.1 Проблема
    11.5.2 Рішення на рівні правила
    11.5.3 Рішення на рівні символу
    11.5.4 COND_P()
    11.6   tLPAREN_ARG (1)
    11.6.1 Проблема
    11.6.2 Дослідження
    11.6.3 У випадку 1 аргументу
    11.6.4 Випадок 2 або більше аргументів
    11.7   tLPAREN_ARG (2)
    11.7.1 Проблема
    11.7.2 Рішення на рівні правила
    11.7.3 {} ітератор
    11.7.4 do end ітератор
    11.7.5 Факт та істина
    12.    Побудова синтаксичного дерева
    12.1   Вузол
    12.1.1 NODE
    12.1.2 Тип вузла
    12.1.3 Ім'я файлу та номер рядка
    12.1.4 rb_node_newnode()
    12.2   Побудова синтаксичного дерева
    12.2.1 YYSTYPE
    12.2.2 Пейзаж з синтаксичним деревом
    12.2.3 Лист
    12.2.4 Гілка
    12.2.5 Ствол
    12.2.6 Два списки
    12.3   Семантичний аналіз
    12.3.1 Помилка в дії
    12.3.2 value_expr()
    12.3.3 Глобальний образ перевірки значення
    12.4   Локальна змінна
    12.4.1 Визначення локальної змінної
    12.4.2 Локальна змінна блоку
    12.4.3 Структура даних
    12.4.4 Область видимості локальної змінної
    12.4.5 push та pop
    12.4.6 Додавання змінної
    12.4.7 Підсумок локальної змінної
    12.4.8 Локальна змінна блоку
    12.4.9 ruby_dyna_vars в парсері
    Розділ III: Оцінка
    13.    Структура оцінювача
    13.1   Контур Розділу III
    13.1.1 Що таке оцінювач
    13.1.2 Характеристики оцінювача ruby
    13.1.3 eval.c
    13.2   Перехід від main через ruby_run до rb_eval
    13.2.1 Граф викликів
    13.2.2 main()
    13.2.3 ruby_init()
    13.2.4 ruby_options()
    13.2.5 ruby_run()
    13.3   rb_eval()
    13.3.1 Контур
    13.3.2 NODE_IF
    13.3.3 NODE_NEWLINE
    13.3.4 Псевдо локальна змінна
    13.3.5 Тег стрибка
    13.3.6 NODE_WHILE
    13.3.7 Оцінка значення while
    13.4   Виняток
    13.4.1 raise
    13.4.2 Глобальний образ
    13.4.3 ensure
    13.4.4 rescue
    14.    Контекст
    14.1   Стек Ruby
    14.1.1 Контекст та стек
    14.1.2 ruby_frame
    14.1.3 ruby_scope
    14.1.4 ruby_block
    14.1.5 ruby_iter
    14.1.6 ruby_dyna_vars
    14.1.7 ruby_class
    14.1.8 ruby_cref
    14.1.9 Макроси PUSH/POP
    14.1.10 Інша умова
    14.2   Визначення модуля
    14.2.1 Дослідження
    14.2.2 NODE_MODULE
    14.2.3 module_setup()
    14.2.4 Побудова області видимості локальної змінної
    14.2.5 Виділення простору пам'яті локальної змінної
    14.2.6 TMP_ALLOC()
    14.2.7 Зміна цілі визначення методу
    14.2.8 Вкладений клас
    14.2.9 Заміна кадрів
    14.3   Визначення методу
    14.3.1 Дослідження
    14.3.2 NODE_DEFN
    14.3.3 copy_node_scope()
    14.3.4 rb_add_method()
    14.4   Присвоєння та посилання
    14.4.1 Локальна змінна
    14.4.2 Константа
    14.4.3 Змінна класу
    14.4.4 Множинне присвоєння
    15.    Метод
    15.1   Пошук методу
    15.1.1 Термінологія
    15.1.2 Дослідження
    15.1.3 SETUP_ARGS()
    15.1.4 rb_call()
    15.1.5 Кеш методу
    15.2   Виклик
    15.2.1 rb_call0()
    15.2.2 PUSH_FRAME()
    15.2.3 rb_call0() -- NODE_CFUNC
    15.2.4 rb_call0() -- NODE_SCOPE
    15.2.5 Встановлення аргументу
    15.2.6 super
    16.    Блок
    16.1   Ітератор
    16.1.1 Глобальний образ
    16.1.2 Push блок
    16.1.3 Виклик методу ітератора
    16.1.4 Виклик блоку
    16.1.5 Цільовий призначений стрибок
    16.1.6 Перевірка блоку
    16.2   Proc
    16.2.1 Виділення об'єкта Proc
    16.2.2 Копіювання кадрів
    16.2.3 Виклик Proc
    16.2.4 Блок та Proc
    17.    Динамічна оцінка
    17.1   Контур
    17.1.1 eval
    17.1.2 module_eval та instance_eval
    17.2   eval
    17.2.1 eval()
    17.2.2 top_local
    17.2.3 Локальна змінна блоку
    17.3   instance_eval
    17.3.1 Глобальний образ
    17.3.2 Після вбудовування
    17.3.3 До вбудовування
    Розділ IV: Краї оцінювача
    18.    Завантаження
    18.1   Контур
    18.1.1 Інтерфейс
    18.1.2 Потік загального управління
    18.1.3 Ціль цього розділу
    18.2   Пошук бібліотеки
    18.2.1 rb_f_require()
    18.2.2 rb_find_file()
    18.2.3 Очікування завантаження
    18.3   Завантаження програми Ruby
    18.3.1 rb_load()
    18.3.2 rb_load_file()
    18.4   Завантаження бібліотеки розширень
    18.4.1 rb_f_require() -- load_dyna
    18.4.2 Огляд зв'язування
    18.4.3 Дійсно динамічне зв'язування
    18.4.4 API динамічного завантаження
    18.4.5 dln_load()
    18.4.6 dln_load() -- dlopen()
    18.4.7 dln_load()-- Win32
    19.    Потік
    19.1   Контур
    19.1.1 Інтерфейс Ruby
    19.1.2 ruby thread
    19.1.3 Чи це витісняючий?
    19.1.4 Система керування
    19.1.5 Що таке перемикання потоків?
    19.1.6 Метод перемикання контексту
    19.1.7 План пояснення
    19.2   Тригер
    19.2.1 Очікування I/O
    19.2.2 Очікування інших потоків
    19.2.3 Очікування часу
    19.2.4 Перемикання через закінчення часу
    19.3   Планування
    19.3.1 rb_thread_schedule()
    19.3.2 select
    19.3.3 Підготовка до select
    19.3.4 Виклик select
    19.3.5 Визначення наступного потоку
    19.3.6 Перемикання потоку
    19.4   Перемикання контексту
    19.4.1 Базова лінія
    19.4.2 rb_thread_save_context()
    19.4.3 rb_thread_restore_context()
    19.4.4 Проблема
    Фінальний розділ: Майбутнє Ruby
    20.1   Проблеми, які потрібно вирішити
    20.1.1 Продуктивність GC
    20.1.2 Реалізація парсера
    20.1.3 Повторно використовуваний парсер
    20.1.4 Приховування коду
    20.1.5 Об'єкт інтерпретатора
    20.1.6 Структура оцінювача
    20.1.7 Швидкість оцінювача
    20.1.8 Реалізація потоку
    20.2   ruby2
    20.2.1 Rite
    20.2.2 Мова опису
    20.2.3 GC
    20.2.4 Парсер
    20.2.5 Оцінювач
    20.2.6 Потік
    20.2.7 M17N
    20.2.8 IO
    20.3   Ruby Hacking Guide
    20.3.1 Покоління GC
    20.3.2 Oniguruma
    20.3.3 ripper
    20.3.4 Замінюючий парсер
    20.3.5 JRuby
    20.3.6 NETRuby
    20.3.7 Як брати участь у розробці Ruby
    20.3.8 В кінці
    Додаток A: Довідник функцій та макросів
    Додаток B: Посилання
    Індекс