---
layout: news_post
title: "Phản bác lỗ hổng CVE-2014-2734"
author: "emboss"
translator:
date: 2014-05-09 05:33:54 +0000
tags: security
lang: vi
---

Chúng tôi vừa được thông báo về một lỗ hổng bảo mật có thể đã được công bố dưới mã
[CVE-2014-2734](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2734).
Tuy nhiên, dựa trên phân tích chi tiết bên dưới, chúng tôi **không** cho rằng Ruby
bị ảnh hưởng.

Lỗ hổng này có thể cho phép kẻ tấn công giả mạo chứng chỉ gốc tùy ý
bằng cách sửa đổi chữ ký của chứng chỉ, thay thế hiệu quả
khóa riêng gốc của chứng chỉ bằng khóa do kẻ tấn công chọn.

## Bằng chứng khái niệm

Sau đây là phân tích của chúng tôi về CVE-2014-2734, chúng tôi đã có thể rút gọn
PoC gốc, mà chúng tôi tin rằng nắm bắt được bản chất của bằng chứng khái niệm:

{% highlight ruby %}
require 'openssl'

forge_key = OpenSSL::PKey::RSA.new(2048)
raw_certificate = File.read("arbitrary.cer")
cert = OpenSSL::X509::Certificate.new(raw_certificate)
resigned_cert = cert.sign(spoof, OpenSSL::Digest::SHA1.new)

resigned_cert.verify(key) #=> true
{% endhighlight %}

Có thể đáng ngạc nhiên khi `X509Certificate#verify` trả về `true`.
Chứng chỉ gốc có thể chứa một
[Subject Public Key Info](http://tools.ietf.org/html/rfc5280#section-4.1.2.7)
trỏ đến khóa công khai gốc khác với khóa công khai của
`forge_key`. Rõ ràng, cặp khóa công khai / riêng được sử dụng để ký lại
chứng chỉ không còn khớp với khóa công khai gốc được tham chiếu trong
Subject Public Key Info. Tại sao `#verify` trả về `true`?

### Cách khóa được xác minh

`X509Certificate#verify` sử dụng hàm
[`X509_verify`](https://github.com/openssl/openssl/blob/master/crypto/x509/x_all.c#L74)
của OpenSSL bên trong, ủy quyền cho
[`ASN1_item_verify`](https://github.com/openssl/openssl/blob/master/crypto/asn1/a_verify.c#L134).
Các hàm này xác minh tính hợp lệ của chữ ký với khóa công khai
đã được trình bày. Tuy nhiên, chúng sẽ **không** xác minh xem khóa đã cho
có thực sự khớp với bất kỳ khóa công khai chủ thể nào được tham chiếu trong chứng chỉ hay không.
Điều này có nghĩa là việc trả về `true` là hành vi mong đợi cho `X509Certificate#verify`
trong tình huống này. Việc bỏ qua kiểm tra này không ảnh hưởng đáng kể đến
bảo mật tổng thể của mô hình tin cậy X.509.

Mục 4.1.1.3 của RFC 5280 nêu rõ rằng bằng cách tính toán
chữ ký của chứng chỉ, CA xác nhận tính đúng đắn của thông tin
chứa trong chứng chỉ. Mặc dù nguyên tắc này bị vi phạm trong đoạn mã ví dụ
trên, nó không gây ra mối đe dọa cho bảo mật. Một chứng chỉ bị giả mạo hoặc
sửa đổi theo cách này không thể bị khai thác trừ khi ai đó có thể thuyết phục bạn
tin tưởng một chứng chỉ vi phạm nguyên tắc này.

## Rủi ro tiềm ẩn

Có hai trường hợp cần xem xét:

### Ký lại chứng chỉ gốc

Là người dùng, chúng ta tin tưởng chứng chỉ gốc vô điều kiện. Ngay cả khi chúng
không chứa thông tin hợp lệ, trạng thái được công nhận công khai như chứng chỉ gốc
là đủ để giữ chúng nguyên vẹn. Chúng là các giá trị được cấu hình sẵn
trong kho tin cậy của trình duyệt hoặc hệ điều hành. Việc đơn giản sở hữu
chúng đã thiết lập trạng thái của chúng như các điểm neo tin cậy hợp lệ. Ví dụ, OpenSSL
tự nó không kiểm tra chữ ký của chứng chỉ gốc tự ký theo mặc định vì cùng lý do,
xem [tài liệu X509_V_FLAG_CHECK_SS_SIGNATURE](https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html).

Một chứng chỉ gốc được ký lại trở thành chứng chỉ "tự ký" trên thực tế
(mặc dù có Subject Public Key Info không chính xác). Điều này không nguy hiểm hơn
một chứng chỉ gốc tự ký bình thường. Trên thực tế, bất kỳ ai cũng có thể
tạo chứng chỉ gốc tự ký hoàn toàn khớp với chứng chỉ gốc
hợp lệ - ngoại trừ chữ ký. Vì chúng ta tin tưởng chứng chỉ gốc
chỉ bằng việc sở hữu, một chứng chỉ giả mạo như vậy là vô nghĩa
nếu không có sự đồng ý chủ động của khách hàng để tin tưởng nó.

### Ký lại chứng chỉ trung gian hoặc lá

Ngoài ra, việc ký lại chứng chỉ không phải gốc cũng không vi phạm bảo mật của
mô hình tin cậy X.509. Mặc dù chúng ta thường không sở hữu trước các loại chứng chỉ
này, việc giả mạo chúng sẽ bị phát hiện trong
[quy trình xác thực đường dẫn](http://tools.ietf.org/html/rfc5280#section-6).
Ở đây, chữ ký của bất kỳ chứng chỉ không phải gốc nào được xác minh bằng khóa công khai
của chứng chỉ phát hành. Tại một điểm nào đó trong chuỗi chứng chỉ, việc giả mạo
cuối cùng sẽ bị phát hiện dưới dạng giá trị chữ ký chứng chỉ không hợp lệ.

## Kết luận

Tóm lại, chúng tôi tin rằng `X509Certificate#verify` hoạt động đúng như mong đợi.
Những người khác đã độc lập đi đến
[cùng kết luận](https://github.com/adrienthebo/cve-2014-2734/)
và do đó chúng tôi đã phản bác CVE-2014-2734, và yêu cầu thu hồi nó.
Bạn có thể tìm phân tích đầy đủ của chúng tôi về
[bằng chứng khái niệm gốc](https://gist.github.com/emboss/91696b56cd227c8a0c13)
kèm theo nhận xét.
